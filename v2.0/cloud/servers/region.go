// vim: ts=8 sw=8 noet ai

package servers

import (
	"fmt"
	"github.com/racker/gorax/v2.0/identity"
	"github.com/racker/perigee"
	"net/http"
)

// A raxRegion represents a Rackspace-hosted region.
type raxRegion struct {
	id            identity.Identity
	entryEndpoint identity.EntryEndpoint
	httpClient    *http.Client
	token         string
}

// Flavors method provides a complete list of machine configurations (called flavors) available at the region.
func (r *raxRegion) Flavors() ([]Flavor, error) {
	var fs []Flavor

	url, _ := r.EndpointByName("flavors")
	err := perigee.Get(url, perigee.Options{
		CustomClient: r.httpClient,
		Results:      &struct{ Flavors *[]Flavor }{&fs},
		MoreHeaders: map[string]string{
			"X-Auth-Token": r.token,
		},
	})
	return fs, err
}

// Images method provides a complete list of images hosted at the region.
func (r *raxRegion) Images() ([]Image, error) {
	var is []Image
	url, _ := r.EndpointByName("images")
	err := perigee.Get(url, perigee.Options{
		CustomClient: r.httpClient,
		Results:      &struct{ Images *[]Image }{&is},
		MoreHeaders: map[string]string{
			"X-Auth-Token": r.token,
		},
	})
	return is, err
}

// Servers method provides a complete list of servers hosted by the user
// at a given region.
func (r *raxRegion) Servers() ([]Server, error) {
	var ss []Server

	url, _ := r.EndpointByName("servers")
	err := perigee.Get(url, perigee.Options{
		CustomClient: r.httpClient,
		Results:      &struct{ Servers *[]Server }{&ss},
		MoreHeaders: map[string]string{
			"X-Auth-Token": r.token,
		},
	})
	return ss, err
}

// CreateServer requests a new server to be created by the cloud provider.
// The user must pass in a pointer to an initialized NewServerContainer structure.
// Please refer to NewServerContainer for more details.
//
// If the NewServer structure lacks a field assignment for AdminPass,
// a password will be automatically generated by OpenStack / Rackspace and
// returned back through the AdminPass field.  Take care; this will be
// the only time this happens; no other means exists in the public API
// to acquire a password for a pre-existing server.
func (r *raxRegion) CreateServer(ns NewServer) (*NewServer, error) {
	var s *NewServer

	ep, err := r.EndpointByName("servers")
	if err != nil {
		return nil, err
	}
	err = perigee.Post(ep, perigee.Options{
		ReqBody: &struct {
			Server *NewServer `json:"server"`
		}{&ns},
		Results: &struct{ Server **NewServer }{&s},
		MoreHeaders: map[string]string{
			"X-Auth-Token": r.token,
		},
		OkCodes: []int{202},
	})
	return s, err
}

// ServerInfoById provides the complete server information record
// given you know its unique ID.
func (r *raxRegion) ServerInfoById(id string) (*Server, error) {
	var s *Server

	baseUrl, err := r.EndpointByName("servers")
	serverUrl := fmt.Sprintf("%s/%s", baseUrl, id)
	err = perigee.Get(serverUrl, perigee.Options{
		Results: &struct{ Server **Server }{&s},
		MoreHeaders: map[string]string{
			"X-Auth-Token": r.token,
		},
	})
	return s, err
}

// DeleteServerById requests that the server with the specified ID
// be removed from your account.  The delete happens asynchronously.
func (r *raxRegion) DeleteServerById(id string) error {
	baseUrl, err := r.EndpointByName("servers")
	serverUrl := fmt.Sprintf("%s/%s", baseUrl, id)
	err = perigee.Delete(serverUrl, perigee.Options{
		MoreHeaders: map[string]string{
			"X-Auth-Token": r.token,
		},
		OkCodes: []int{204},
	})
	return err
}

// SetAdminPassword requests that the server with the specified ID
// have its administrative password changed.  For Linux, BSD, or other
// pure-POSIX-compliant systems, this administrator corresponds to the
// root user.  For Windows machines, the Administrator user will be
// affected.
func (r *raxRegion) SetAdminPassword(id string, pw string) error {
	ep, err := r.EndpointByName("servers")
	if err != nil {
		return err
	}
	endpoint := fmt.Sprintf("%s/%s/action", ep, id)
	err = perigee.Post(endpoint, perigee.Options{
		ReqBody: &struct {
			ChangePassword struct {
				AdminPass string `json:"adminPass"`
			} `json:"changePassword"`
		}{
			struct {
				AdminPass string `json:"adminPass"`
			}{pw},
		},
		OkCodes: []int{202},
		MoreHeaders: map[string]string{
			"X-Auth-Token": r.token,
		},
	})
	return err
}

// RebootServer requests that the server with the specified ID be rebooted.
// Two reboot mechanisms exist.
//
// - Hard.  This will physically power-cycle the unit.
// - Soft.  This will attempt to use the server's software-based mechanisms to restart the machine.
//          E.g., "shutdown -r now" on Linux.

func (r *raxRegion) RebootServer(id string, isHard bool) error {
	baseUrl, err := r.EndpointByName("servers")
	serverUrl := fmt.Sprintf("%s/%s/action", baseUrl, id)
	typ := "SOFT"
	if isHard {
		typ = "HARD"
	}
	err = perigee.Post(serverUrl, perigee.Options{
		ReqBody: &struct {
			Reboot struct {
				Type string `json:"type"`
			} `json:"reboot"`
		}{
			struct {
				Type string `json:"type"`
			}{typ},
		},
		OkCodes: []int{202},
		MoreHeaders: map[string]string{
			"X-Auth-Token": r.token,
		},
	})
	return err
}

// RebuildServer removes all data on the server and replaces it with the specified image
// on the specified flavor.
func (r *raxRegion) RebuildServer(id string, ns NewServer) (*Server, error) {
	var s *Server
	baseUrl, err := r.EndpointByName("servers")
	serverUrl := fmt.Sprintf("%s/%s/action", baseUrl, id)
	err = perigee.Post(serverUrl, perigee.Options{
		ReqBody: &struct {
			Rebuild NewServer `json:"rebuild"`
		}{Rebuild: ns},
		Results: &struct {
			Server **Server `json:"server"`
		}{&s},
		OkCodes: []int{202},
		MoreHeaders: map[string]string{
			"X-Auth-Token": r.token,
		},
	})
	return s, err
}

// ResizeServer can be a short-hand for RebuildServer where only the size of the server
// changes.  Note that after the resize operation is requested, you will need to confirm
// the resize has completed for changes to take effect permanently.  Changes will assume
// to be confirmed even without an explicit confirmation after 24 hours from the initial
// request.
func (r *raxRegion) ResizeServer(id, name, flavor, diskConfig string) error {
	baseUrl, err := r.EndpointByName("servers")
	serverUrl := fmt.Sprintf("%s/%s/action", baseUrl, id)
	rr := ResizeRequest{
		Name:       name,
		FlavorRef:  flavor,
		DiskConfig: diskConfig,
	}
	err = perigee.Post(serverUrl, perigee.Options{
		ReqBody: &struct {
			Resize ResizeRequest `json:"resize"`
		}{rr},
		OkCodes: []int{202},
		MoreHeaders: map[string]string{
			"X-Auth-Token": r.token,
		},
	})
	return err
}

// ConfirmResizeServer will acknowledge a server's resized configuration.
func (r *raxRegion) ConfirmResizeServer(id string) error {
	baseUrl, err := r.EndpointByName("servers")
	serverUrl := fmt.Sprintf("%s/%s/action", baseUrl, id)
	err = perigee.Post(serverUrl, perigee.Options{
		ReqBody: &struct {
			ConfirmResize *int `json:"confirmResize"`
		}{nil},
		OkCodes: []int{204},
		MoreHeaders: map[string]string{
			"X-Auth-Token": r.token,
		},
	})
	return err
}

// RevertResizeServer will reject a server's resized configuration, thus
// rolling back to the original server.
func (r *raxRegion) RevertResizeServer(id string) error {
	baseUrl, err := r.EndpointByName("servers")
	serverUrl := fmt.Sprintf("%s/%s/action", baseUrl, id)
	err = perigee.Post(serverUrl, perigee.Options{
		ReqBody: &struct {
			RevertResize *int `json:"revertResize"`
		}{nil},
		OkCodes: []int{204},
		MoreHeaders: map[string]string{
			"X-Auth-Token": r.token,
		},
	})
	return err
}

// EndpointByName computes a resource URL, assuming a valid name.
// An error is returned if an invalid or unsupported endpoint name is given.
//
// It is an error for application software to invoke this method.
// This method exists and is publicly available only to support testing.
func (r *raxRegion) EndpointByName(name string) (string, error) {
	var supportedEndpoint map[string]bool = map[string]bool{
		"images":  true,
		"flavors": true,
		"servers": true,
	}

	if supportedEndpoint[name] {
		api := fmt.Sprintf("%s/%s", r.entryEndpoint.PublicURL, name)
		return api, nil
	}
	return "", fmt.Errorf("Unsupported endpoint")
}

// UseClient configures the region client to use a specific net/http client.
// This allows you to configure a custom HTTP transport for specialized requirements.
// You normally wouldn't need to set this, as the net/http package makes reasonable
// choices on its own.  Customized transports are useful, however, if extra logging
// is required, or if you're using unit tests to isolate and verify correct behavior.
func (r *raxRegion) UseClient(cl *http.Client) {
	r.httpClient = cl
}

// makeRegionalClient creates a structure that implements the Region interface.
func makeRegionalClient(id identity.Identity, e identity.EntryEndpoint) (Region, error) {
	t, err := id.Token()
	if err != nil {
		return nil, err
	}
	return &raxRegion{
		id:            id,
		entryEndpoint: e,
		token:         t,
		httpClient:    &http.Client{},
	}, nil
}
